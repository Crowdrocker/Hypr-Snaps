
##################### Noctalia Docs Create a Matugen template ########################
This guide walks you through adding a new Matugen template to Noctalia.

# Step 1: Create the Template File
First, create your template file in the Matugen templates directory.
For example, if you’re making one for kitty, create:

Assets/MatugenTemplates/kitty.conf

# Generated by Matugen via Noctalia
color0 {{colors.surface.default.hex}}
color1 {{colors.error.default.hex}}
color2 {{colors.tertiary.default.hex}}
color3 {{colors.secondary.default.hex}}
color4 {{colors.primary.default.hex}}
color5 {{colors.primary.default.hex}}
color6 {{colors.secondary.default.hex}}
color7 {{colors.on_background.default.hex}}
color8 {{colors.outline.default.hex}}
color9 {{colors.secondary_fixed_dim.default.hex}}
color10 {{colors.tertiary_container.default.hex}}
color11 {{colors.surface_container.default.hex}}
color12 {{colors.primary_container.default.hex}}
color13 {{colors.on_primary_container.default.hex}}
color14 {{colors.surface_variant.default.hex}}
color15 {{colors.on_background.default.hex}}

cursor {{colors.primary.default.hex}}
cursor_text_color {{colors.on_surface.default.hex}}

foreground            {{colors.on_surface.default.hex}}
background            {{colors.surface.default.hex}}
selection_foreground  {{colors.on_secondary.default.hex}}
selection_background  {{colors.secondary_fixed_dim.default.hex}}
url_color             {{colors.primary.default.hex}}

Matugen uses template variables to map Material Design 3 colors to different app formats.
You can find all the available variables and their Material 3 mappings in the Matugen wiki.

# Step 2: Add a Settings Toggle
Next, create a setting to control whether this template is generated.
Open Commons/Settings.qml, find the templates JsonObject, and add a new property:

property JsonObject templates: JsonObject {
    // ... existing properties ...
    property bool kitty: false
}

This adds a persistent toggle that defaults to false.

# Step 3: Wire It Into the Config Generator
Now tell the system when to use the new template.
Open Services/AppThemeService.qml and find the predefinedTemplateConfigs object.
Add your template config alongside the existing ones:

"kitty": {
  "input": "kitty.conf",
  "outputs": [{
      "path": "~/.config/kitty/themes/noctalia.conf"
    }],
  "postProcess": () => `${colorsApplyScript} kitty\n`
}

The postProcess function tells the system to run a script after generating the colors, which is useful for reloading the application’s theme.

# Step 4: Show the Toggle Only if the Program Exists
We don’t want to display the toggle if kitty isn’t installed.
Open Services/ProgramCheckerService.qml and:

Add a property to track availability:
property bool kittyAvailable: false

Add an entry to the programsToCheck object:
programsToCheck: {
    // ... existing entries ...
    "kittyAvailable": ["which", "kitty"],
}

This automatically updates kittyAvailable when the program is detected.

# Step 5: Add the UI Toggle
Finally, add the toggle to the settings panel.
Open Modules/SettingsPanel/Tabs/ColorSchemeTab.qml, find the appropriate section (or create one), and insert:

NCheckbox {
    label: "kitty"
    description: ProgramCheckerService.kittyAvailable
        ? "Write ~/.config/kitty/themes/noctalia.conf and reload"
        : "Requires kitty to be installed"
    checked: Settings.data.templates.kitty
    enabled: ProgramCheckerService.kittyAvailable
    opacity: ProgramCheckerService.kittyAvailable ? 1.0 : 0.6
    onToggled: checked => {
        if (ProgramCheckerService.kittyAvailable) {
            Settings.data.templates.kitty = checked
            if (Settings.data.colorSchemes.useWallpaperColors)
                AppThemeService.generateFromWallpaper()
            else if (Settings.data.colorSchemes.generateTemplatesForPredefined)
                AppThemeService.generateFromPredefinedScheme(ColorSchemeService.getCurrentScheme())
        }
    }
}

This checkbox:

Shows a helpful description based on whether kitty is installed
Disables itself automatically if the program isn’t available
Regenerates colors right away when toggled (for both wallpaper and predefined schemes)
How Color Generation Works
Noctalia supports two different color generation modes:

Wallpaper-Based Colors
When Settings.data.colorSchemes.useWallpaperColors is enabled, the system uses Matugen to analyze the current wallpaper and generates a complete Material Design 3 color palette. This palette is then used to generate all enabled templates using the standard Matugen workflow.

Predefined Color Schemes
When wallpaper colors are disabled, Noctalia uses predefined color schemes (like Nord, Dracula, Catppuccin, etc.). For these schemes, the system:

Generates a Material Design 3 palette - Uses ColorsConvert.js helper functions to create a complete Material Design 3 color palette from the predefined scheme’s key colors
Maps predefined colors intelligently - Primary, secondary, tertiary, error, and surface colors from the predefined scheme are used as the foundation
Generates complementary colors - Container colors, “on” colors (for text/icons), surface variants, and outline colors are generated using color theory algorithms
Processes templates directly - Templates are copied and color placeholders are replaced with the generated Material Design 3 colors using sed
This approach ensures that predefined color schemes maintain their authentic look while providing a complete Material Design 3 palette for consistent theming across all applications.

# Terminal Templates

Terminal templates are handled specially - they use predefined color schemes directly for better contrast and readability rather than the generated Material Design 3 palette. This ensures terminal applications have optimal readability with high contrast colors.


##################### Noctalia Docs Create a Bar widget ########################
# Step 1: Create the Widget File
Create a new file at Modules/Bar/Widgets/HelloWorld.qml:

import QtQuick
import QtQuick.Layouts
import qs.Commons
import qs.Services

Rectangle {
  id: root

  // Provided by Bar.qml via NWidgetLoader
  property var screen
  property real scaling: 1.0
  property string widgetId: ""
  property string section: ""
  property int sectionWidgetIndex: -1
  property int sectionWidgetsCount: 0

  // Access your metadata and per-instance settings
  property var widgetMetadata: BarWidgetRegistry.widgetMetadata[widgetId]
  property var widgetSettings: {
    if (section && sectionWidgetIndex >= 0) {
      var widgets = Settings.data.bar.widgets[section]
      if (widgets && sectionWidgetIndex < widgets.length) {
        return widgets[sectionWidgetIndex]
      }
    }
    return {}
  }

  implicitHeight: Math.round(Style.capsuleHeight * scaling)
  implicitWidth: Math.round(120 * scaling)
  radius: Math.round(Style.radiusS * scaling)
  color: Color.mSurfaceVariant
  border.width: Math.max(1, Style.borderS * scaling)
  border.color: Color.mOutline

  RowLayout {
    id: layout
    anchors.fill: parent
    anchors.margins: Style.marginXS * scaling
    spacing: Style.marginXS * scaling

    NText {
      text: widgetSettings.text !== undefined ? widgetSettings.text : (widgetMetadata?.text || "Hello")
      font.pointSize: Style.fontSizeXS * scaling
      font.weight: Style.fontWeightBold
      color: Color.mPrimary
      Layout.alignment: Qt.AlignVCenter | Qt.AlignHCenter
    }
  }
}

# Step 2: Register the Widget in the Registry
Open Services/BarWidgetRegistry.qml and make three small edits:

Add the widget to the widgets map:
"HelloWorld": helloWorldComponent,

Provide defaults in widgetMetadata (this seeds per-instance settings when adding from the UI):
"HelloWorld": {
  "allowUserSettings": true,
  "text": "Hello"
},

Add a Component entry so the registry can instantiate it:
property Component helloWorldComponent: Component {
  HelloWorld {}
}

Example

The text field is just an example of a simple per-widget setting copied to the user’s settings when they add it.

# Step 3: Verify It Shows Up in the BarTab Selector
The Bar settings UI (Modules/SettingsPanel/Tabs/BarTab.qml) reads available widgets from BarWidgetRegistry.getAvailableWidgets() and builds the selector automatically.
Once registered, HelloWorld appears in the add-widget menu for Left/Center/Right sections.

# Step 4: Test the Widget from the Settings Panel
Open Settings → Bar → Widgets Positioning.
In the desired section (Left/Center/Right), click “Add” and select HelloWorld.
Drag to reorder if needed.

# Step 5: Add a Settings UI
To let users change the widget text via the Bar settings dialog, create a settings component and map it.

1) Create Modules/SettingsPanel/Bar/WidgetSettings/HelloWorldSettings.qml:
import QtQuick
import QtQuick.Layouts
import qs.Commons
import qs.Widgets

ColumnLayout {
  // Provided by the dialog loader
  property var widgetData
  property var widgetMetadata

  // Local state – initialize from widgetData with metadata fallback
  property string textValue: widgetData?.text !== undefined ? widgetData.text : (widgetMetadata?.text || "Hello")

  NText {
    text: "HelloWorld Text"
    font.pointSize: Style.fontSizeM * scaling
    font.weight: Style.fontWeightBold
    color: Color.mOnSurface
  }

  NTextInput {
    Layout.fillWidth: true
    placeholderText: "Enter text to display..."
    text: textValue
    onTextChanged: textValue = text
  }

  // Called by the dialog's Apply button
  function saveSettings() {
    // Return a new settings object; preserve other keys
    var updated = Object.assign({}, widgetData)
    updated.text = textValue
    return updated
  }
}

2) Map the settings component in Modules/SettingsPanel/Bar/BarWidgetSettingsDialog.qml:
// Inside loadWidgetSettings() widgetSettingsMap
"HelloWorld": "WidgetSettings/HelloWorldSettings.qml",

Now the gear icon on the widget chip opens a dialog with an input field to edit the text.

Tip

The saveSettings() function ensures your changes are written back into the JSON safely.

# Step 6 (Optional): Add More Settings Later
Add keys under widgetMetadata["HelloWorld"] for new defaults (e.g., icon, color, etc.).
They’ll be copied into a widget instance the first time the user adds it.
To adjust existing instances, the user can edit in the UI if supported, or modify their settings JSON.
This inserts the widget with default settings for first-run configurations.
Existing users won’t be affected unless they reset or remove their settings file.

That’s it! You’ve now built a simple, editable widget for the Bar and exposed it cleanly in the settings UI.

# KEYBINDS

Core Functions
Function	Command	Description
Application Launcher	qs -c noctalia-shell ipc call launcher toggle	Open/close the application launcher
Control Center	qs -c noctalia-shell ipc call controlCenter toggle	Toggle the control center visibility
Settings	qs -c noctalia-shell ipc call settings toggle	Open/close the settings window

Quick Access
Function	Command	Description
Clipboard History	qs -c noctalia-shell ipc call launcher clipboard	Access your clipboard history
Calculator	qs -c noctalia-shell ipc call launcher calculator	Quick calculator access
Session Menu	qs -c noctalia-shell ipc call sessionMenu toggle	Logout, reboot, shutdown…


System Controls
Audio Management
Function	Command	Description
Volume Up	qs -c noctalia-shell ipc call volume increase	Increase system volume
Volume Down	qs -c noctalia-shell ipc call volume decrease	Decrease system volume
Mute Output	qs -c noctalia-shell ipc call volume muteOutput	Toggle output audio mute
Input Up	qs -c noctalia-shell ipc call volume increaseInput	Increase input volume
Input Down	qs -c noctalia-shell ipc call volume decreaseInput	Decrease input volume
Mute Input	qs -c noctalia-shell ipc call volume muteInput	Toggle input audio mute


Display & Brightness
Function	Command	Description
Brightness Up	qs -c noctalia-shell ipc call brightness increase	Increase screen brightness
Brightness Down	qs -c noctalia-shell ipc call brightness decrease	Decrease screen brightness
Media
Function	Command	Description
Screen record toggle	qs -c noctalia-shell ipc call screenRecorder toggle	Start / stop the screen recording


Notifications
Function	Command	Description
Notification History	qs -c noctalia-shell ipc call notifications toggleHistory	View past notifications
Do Not Disturb	qs -c noctalia-shell ipc call notifications toggleDND	Toggle notification silence mode
Clear Notification History	qs -c noctalia-shell ipc call notifications clear	Clear notification history

Security & Privacy
Function	Command	Description
Lock Screen	qs -c noctalia-shell ipc call lockScreen toggle	Lock your screen
Idle Inhibitor	qs -c noctalia-shell ipc call idleInhibitor toggle	Prevent system from going idle


Appearance
Visibility
Function	Command	Description
Toggle Bar Visibility	qs -c noctalia-shell ipc call bar toggle	Switch between invisible and visible


Theme Controls
Function	Command	Description
Toggle Dark Mode	qs -c noctalia-shell ipc call darkMode toggle	Switch between light/dark themes
Set Dark Mode	qs -c noctalia-shell ipc call darkMode setDark	Force dark theme
Set Light Mode	qs -c noctalia-shell ipc call darkMode setLight	Force light theme


Wallpaper Management
Function	Command	Description
Toggle Selector	qs -c noctalia-shell ipc call wallpaper toggle	Toggle the wallpaper selector
Set Wallpaper	qs -c noctalia-shell ipc call wallpaper set $path $monitor	Set specific wallpaper on a monitor
Random Wallpaper	qs -c noctalia-shell ipc call wallpaper random	Apply a random wallpaper
Toggle Automation	qs -c noctalia-shell ipc call wallpaper toggleAutomation	Toggle wallpaper automation
Enable Automation	qs -c noctalia-shell ipc call wallpaper enableAutomation	Enable wallpaper automation
Disable Automation	qs -c noctalia-shell ipc call wallpaper disableAutomation	Disable wallpaper automation



binds {
    // Core Noctalia binds
    Mod+Space { spawn "qs" "-c" "noctalia-shell" "ipc" "call" "launcher" "toggle"; }
    Mod+S { spawn "qs" "-c" "noctalia-shell" "ipc" "call" "controlCenter" "toggle"; }
    Mod+Comma { spawn "qs" "-c" "noctalia-shell" "ipc" "call" "settings" "toggle"; }

    // Audio controls
    XF86AudioRaiseVolume { spawn "qs" "-c" "noctalia-shell" "ipc" "call" "volume" "increase"; }
    XF86AudioLowerVolume { spawn "qs" "-c" "noctalia-shell" "ipc" "call" "volume" "decrease"; }
    XF86AudioMute { spawn "qs" "-c" "noctalia-shell" "ipc" "call" "volume" "muteOutput"; }

    // Brightness controls
    XF86MonBrightnessUp { spawn "qs" "-c" "noctalia-shell" "ipc" "call" "brightness" "increase"; }
    XF86MonBrightnessDown { spawn "qs" "-c" "noctalia-shell" "ipc" "call" "brightness" "decrease"; }

    // Utility shortcuts
    Mod+V { spawn "qs" "-c" "noctalia-shell" "ipc" "call" "launcher" "clipboard"; }
    Mod+C { spawn "qs" "-c" "noctalia-shell" "ipc" "call" "launcher" "calculator"; }
    Mod+L { spawn "qs" "-c" "noctalia-shell" "ipc" "call" "lockScreen" "toggle"; }
}


# Running the shell

Autostart by your Wayland compositor
This is the recommended method for launching noctalia-shell, as it integrates with your window manager.

For the Niri compositor, add the following line to the end of your configuration file, typically located at ~/.config/niri/config.kdl

spawn-at-startup "qs" "-c" "noctalia-shell"

For the Hyprland compositor, append this line to your configuration file, typically located at ~/.config/hypr/hyprland.conf

exec-once = qs -c noctalia-shell

Important

Be aware that the command might need to be adjusted based on how you installed noctalia-shell.
Manual installation: If you installed Noctalia into ~/.config/quickshell/, you can use qs to start it. For keybindings, you must use qs ipc ... instead.
Running as a Systemd Service (Advanced)
For more robust process management, you can configure Noctalia to run as a systemd user service. This approach provides automatic restarts on failure and centralizes logging with journalctl.

1. Create the service file
First, create a new service definition file at ~/.config/systemd/user/noctalia.service with the following content:

[Unit]
Description=Noctalia Shell Service
PartOf=graphical-session.target
After=graphical-session.target

[Service]
ExecStart=qs -c noctalia-shell
Restart=on-failure
RestartSec=1

[Install]
WantedBy=graphical-session.target

2. Enable and Start the Service
Next, enable the service to have it start automatically with your graphical session.

If you use a compositor like Niri, it’s best to tie Noctalia directly to it. This ensures they start and stop together.

Terminal window
# Example for Niri users
systemctl --user add-wants niri.service noctalia.service

Alternatively, you can enable it more generally with:

Terminal window
systemctl --user enable --now noctalia.service

Manual Launch for Debugging
The most direct way to run Noctalia for testing or debugging is to invoke it through Quickshell. Open a terminal and execute:

Terminal window
qs -c noctalia-shell



# Installation
Noctalia is packaged for Arch Linux and NixOS, but can also be installed manually in other distributions.

Arch Linux
Using AUR (Recommended)
The simplest way to install Noctalia on Arch Linux is through the Arch User Repository (AUR). This method installs the shell system-wide and handles dependencies automatically.

Please replace with your AUR helper of choice.

Terminal window
paru -S noctalia-shell

Development Version
For the latest features and fixes, you can install the development version directly from the Git repository:

Terminal window
paru -S noctalia-shell-git

Caution

The development version may be less stable than the official release. Use this version if you want to test the latest features or contribute to development.

Manual Installation
If you prefer to install Noctalia locally or want more control over the installation process, you can install it manually to your user configuration directory. This method works on any Linux distribution.

Step 1: Install required dependencies

For Arch Linux:

Terminal window
# Core dependencies (required)
paru -S quickshell ttf-roboto inter-font gpu-screen-recorder brightnessctl

# Desktop monitor brightness (may cause instability with some monitors)
paru -S ddcutil

# Optional dependencies
paru -S cliphist matugen-git cava wlsunset xdg-desktop-portal

For other distributions, install the equivalent packages using your package manager.

Step 2: Download and install Noctalia

Terminal window
mkdir -p ~/.config/quickshell/noctalia-shell && \
curl -sL https://github.com/noctalia-dev/noctalia-shell/releases/latest/download/noctalia-latest.tar.gz | \
tar -xz --strip-components=1 -C ~/.config/quickshell/noctalia-shell

Dependencies Explained
Required:

quickshell - Core shell framework
ttf-roboto - Default UI font
inter-font - Headers font (clock on LockScreen, etc.)
gpu-screen-recorder - Screen recording functionality
brightnessctl - Internal/laptop monitor brightness control
Hardware-specific:

ddcutil - Desktop monitor brightness control (⚠️ may introduce system instability with certain monitors)
Optional but recommended:

cliphist - Clipboard history support
matugen-git - Material You color scheme generation
cava - Audio visualizer component
wlsunset - Night light functionality
xdg-desktop-portal - Enables “Portal” option in screen recorder
Tip

Manual installation keeps Noctalia contained within your user directory, making it easy to remove or update without affecting system packages.

Compositor Settings
For the best experience with Noctalia, you’ll need to configure your compositor with some specific settings.

Niri
Add these settings to your Niri configuration file (usually ~/.config/niri/config.kdl):

window-rule {
    geometry-corner-radius 20
    clip-to-geometry true
}

layer-rule {
    match namespace="^quickshell-overview$"
    place-within-backdrop true
}

debug {
    honor-xdg-activation-with-invalid-serial
}

These settings ensure:

Proper window activation handling
Rounded corners for a modern look
Correct backdrop placement for the overview panel
Allows Notification actions (honor-xdg-activation-with-invalid-serial)
Makes the file picker float (match app-id="qs")
Note

The configuration files are saved in ~/.config/noctalia/ and the cache files are saved in ~/.cache/noctalia/.




# Create a Predefined Color Scheme
This guide walks you through adding a new predefined color scheme to Noctalia.

Overview
Adding a new predefined color scheme involves five steps:

Create the scheme directory
Create the main scheme file
Create terminal themes
Test your scheme
Add translations
Step 1: Create the Scheme Directory
Create a new directory in the ColorScheme assets folder:

Assets/ColorScheme/YourSchemeName/

For example, if you’re creating a “Monokai” scheme:

Assets/ColorScheme/Monokai/

Step 2: Create the Main Scheme File
Create the main scheme file named after your scheme:

Assets/ColorScheme/Monokai/Monokai.json

{
    "dark": {
        "mPrimary": "#a6e22e",
        "mOnPrimary": "#272822",
        "mSecondary": "#66d9ef",
        "mOnSecondary": "#272822",
        "mTertiary": "#f92672",
        "mOnTertiary": "#272822",
        "mError": "#f92672",
        "mOnError": "#272822",
        "mSurface": "#272822",
        "mOnSurface": "#f8f8f2",
        "mSurfaceVariant": "#3e3d32",
        "mOnSurfaceVariant": "#a6e22e",
        "mOutline": "#75715e",
        "mShadow": "#272822"
    },
    "light": {
        "mPrimary": "#a6e22e",
        "mOnPrimary": "#f8f8f2",
        "mSecondary": "#66d9ef",
        "mOnSecondary": "#f8f8f2",
        "mTertiary": "#f92672",
        "mOnTertiary": "#f8f8f2",
        "mError": "#f92672",
        "mOnError": "#f8f8f2",
        "mSurface": "#f8f8f2",
        "mOnSurface": "#272822",
        "mSurfaceVariant": "#e6e1dc",
        "mOnSurfaceVariant": "#272822",
        "mOutline": "#a6e22e",
        "mShadow": "#d8d8d8"
    }
}

Color Properties Explained
Each color scheme must define both dark and light variants with these Material Design 3 properties:

mPrimary - Primary color (buttons, links, highlights)
mOnPrimary - Text/icon color on primary surfaces
mSecondary - Secondary accent color
mOnSecondary - Text/icon color on secondary surfaces
mTertiary - Tertiary accent color
mOnTertiary - Text/icon color on tertiary surfaces
mError - Error/warning color
mOnError - Text/icon color on error surfaces
mSurface - Main background color
mOnSurface - Primary text color
mSurfaceVariant - Secondary background color (cards, panels)
mOnSurfaceVariant - Text color on surface variants
mOutline - Border/divider color
mShadow - Shadow color
Color Selection Guidelines
Primary Color: Choose a distinctive color that represents your scheme’s character
Secondary/Tertiary: Use complementary colors that work well with the primary
Surface Colors: Ensure good contrast for readability
Error Color: Typically red-based for universal recognition
Outline Colors: Should provide subtle separation without being distracting
Step 3: Create Terminal Themes
Create terminal-specific themes for better contrast and readability. Terminal themes bypass the Material Design 3 generation and use your scheme’s colors directly.

Directory Structure
Create terminal theme directories:

Assets/ColorScheme/Monokai/
├── Monokai.json
└── terminal/
    ├── foot/
    │   ├── Monokai-dark
    │   └── Monokai-light
    ├── ghostty/
    │   ├── Monokai-dark
    │   └── Monokai-light
    └── kitty/
        ├── Monokai-dark.conf
        └── Monokai-light.conf

Foot Terminal Theme
Assets/ColorScheme/Monokai/terminal/foot/Monokai-dark

[colors]
background=272822
foreground=f8f8f2

# Normal colors
regular0=272822
regular1=f92672
regular2=a6e22e
regular3=f4bf75
regular4=66d9ef
regular5=ae81ff
regular6=a1efe4
regular7=f8f8f2

# Bright colors
bright0=75715e
bright1=f92672
bright2=a6e22e
bright3=f4bf75
bright4=66d9ef
bright5=ae81ff
bright6=a1efe4
bright7=f9f8f5

[cursor]
color=f8f8f2 272822

Ghostty Terminal Theme
Assets/ColorScheme/Monokai/terminal/ghostty/Monokai-dark

[colors]
background=272822
foreground=f8f8f2

# Normal colors
regular0=272822
regular1=f92672
regular2=a6e22e
regular3=f4bf75
regular4=66d9ef
regular5=ae81ff
regular6=a1efe4
regular7=f8f8f2

# Bright colors
bright0=75715e
bright1=f92672
bright2=a6e22e
bright3=f4bf75
bright4=66d9ef
bright5=ae81ff
bright6=a1efe4
bright7=f9f8f5

[cursor]
color=f8f8f2 272822

Kitty Terminal Theme
Assets/ColorScheme/Monokai/terminal/kitty/Monokai-dark.conf

color0 #272822
color1 #f92672
color2 #a6e22e
color3 #f4bf75
color4 #66d9ef
color5 #ae81ff
color6 #a1efe4
color7 #f8f8f2
color8 #75715e
color9 #f92672
color10 #a6e22e
color11 #f4bf75
color12 #66d9ef
color13 #ae81ff
color14 #a1efe4
color15 #f9f8f5
background #272822
selection_foreground #272822
cursor #f8f8f2
cursor_text_color #272822
foreground #f8f8f2
selection_background #f8f8f2

Terminal Color Mapping
Terminal themes use a standard 16-color palette:

colors 0-7: Normal colors (dark background variants)
colors 8-15: Bright colors (lighter variants)
background: Terminal background
foreground: Primary text color
cursor: Cursor color and text color
selection_foreground/background: Text selection colors
Step 4: Test Your Scheme
Place your scheme files in the correct directories
Restart Noctalia to load the new scheme
Open settings and navigate to Color Scheme
Select your scheme from the predefined schemes list
Test both dark and light modes
Verify terminal themes work correctly
Check Material Design 3 generation if you have templates enabled
Testing Checklist
 Scheme appears in the predefined schemes list
 Dark mode variant works correctly
 Light mode variant works correctly
 Terminal themes apply correctly
 Material Design 3 templates generate properly
 Colors have good contrast and readability
 Scheme name displays correctly
Step 5: Add Translations
Add translations for your scheme name in the translation files:

Assets/Translations/en.json

{
  "color-scheme": {
    "predefined": {
      "schemes": {
        "Monokai": "Monokai"
      }
    }
  }
}

Assets/Translations/fr.json

{
  "color-scheme": {
    "predefined": {
      "schemes": {
        "Monokai": "Monokai"
      }
    }
  }
}

Add translations for all supported languages:

en.json (English)
fr.json (French)
de.json (German)
es.json (Spanish)
pt.json (Portuguese)
zh-CN.json (Chinese Simplified)
How Predefined Schemes Work
Color Generation Process
When a predefined scheme is selected:

Scheme Loading: The system loads your SchemeName.json file
Variant Selection: Chooses dark or light variant based on current mode
Material Design 3 Generation: Uses ColorsConvert.js to generate a complete Material Design 3 palette
Template Processing: Applies colors to enabled Matugen templates
Terminal Theme Application: Uses terminal-specific themes for better contrast
Material Design 3 Palette Generation
The system automatically generates complementary colors:

Container Colors: Lighter/darker variants of primary colors
“On” Colors: High-contrast text colors for each surface
Surface Variants: Progressive elevation levels
Outline Colors: Border and divider colors
Shadow Colors: Drop shadow colors
Terminal Theme Special Handling
Terminal themes bypass Material Design 3 generation and use your scheme’s colors directly for optimal readability and contrast.

Color Scheme Design Tips
Choosing Colors
Start with a Base: Choose 2-3 core colors that define your scheme’s character
Consider Accessibility: Ensure sufficient contrast ratios (WCAG AA minimum)
Test Both Modes: Dark and light variants should both be usable
Think About Usage: Consider how colors will look in different contexts
Popular Color Scheme Sources
Existing Themes: Adapt popular themes (Dracula, Nord, Catppuccin)
Design Systems: Use established design system color palettes
Nature Inspiration: Draw colors from natural environments
Tools for Color Selection
Color Pickers: Use tools like Coolors.co or Adobe Color
Contrast Checkers: Verify accessibility with WebAIM contrast checker
Preview Tools: Test colors in actual applications
Terminal Testing: Verify terminal themes work well for coding
Advanced Customization
Custom Color Algorithms
You can modify Helpers/ColorsConvert.js to change how Material Design 3 colors are generated:

Container Generation: Adjust how container colors are created
Surface Variants: Modify elevation level calculations
Outline Colors: Customize border color generation
“On” Color Logic: Change text color contrast calculations
Scheme Variants
Create multiple variants of your scheme:

Assets/ColorScheme/Monokai/
├── Monokai.json
├── Monokai-Pro.json
├── Monokai-Classic.json
└── terminal/
    └── ...

Dynamic Schemes
For advanced users, you can create schemes that adapt based on:

Time of day
System preferences
User settings
External factors
Troubleshooting
Common Issues
Scheme Not Appearing: Check file naming and directory structure
Colors Not Applying: Verify JSON syntax and color format
Poor Contrast: Use contrast checking tools to verify readability
Terminal Themes Broken: Check terminal-specific file formats
Translation Missing: Ensure scheme name is in all translation files
Debug Tips
Check Logs: Look for color scheme loading errors in Noctalia logs
Validate JSON: Use JSON validators to check syntax
Test Incrementally: Add one component at a time
Compare Working Schemes: Use existing schemes as references
Testing Your Scheme

Always test your scheme with both dark and light modes, and verify that terminal themes provide good contrast for coding work.

Terminal Themes

Terminal themes are crucial for developer workflows. Ensure your terminal colors provide excellent readability and syntax highlighting support.

Accessibility

Always verify that your color scheme meets accessibility guidelines, especially for users with visual impairments.






















